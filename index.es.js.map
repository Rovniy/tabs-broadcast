{"version":3,"file":"index.es.js","sources":["src/config.ts","src/tabsWorker.ts","src/tabsBroadcast.ts"],"sourcesContent":["/**\n * @file config.ts\n * @description Configuration file for the TabsBroadcast libraries.\n *\n * This file contains the default configuration options and constants used throughout\n * the TabsBroadcast and TabsWorker libraries. It sets up the default values for various\n * settings and provides a dictionary for common terms used within the libraries.\n *\n * License: MIT\n * Author: Andrei (Ravy) Rovnyi\n */\nimport type { TConfig } from './types';\n\nexport default {\n\tdefaultConfig: {\n\t\tchannelName: 'xploit_tab_channel', // Broadcast channel name\n\t\tlayer: 'default_layer',\n\t\tlistenOwnChannel: true, // Listen broadcast event on current tab\n\t\temitByPrimaryOnly: true, // Emits event only by Primary tab\n\t\tonBecomePrimary: () => {}, // Global event when current tab become Primary\n\t},\n\tdict: {\n\t\ttab_prefix: 'xploit_tab_id_',\n\t\tslave : 'xploit_slave',\n\t\tprimary : 'xploit_primary',\n\t\tprimaryTabId : 'xploit_primary_tab_id',\n\t\tprimaryStatusChanged : 'XPLOIT_TAB_STATUS_CHANGED',\n\t}\n} as TConfig\n","/**\n * @file tabsWorker.ts\n * @description A class to manage browser tabs, assigning a primary tab and handling the status changes among tabs.\n *\n * This library ensures that a single browser tab is marked as the primary tab,\n * while others are marked as slave tabs. When the primary tab is closed, the\n * status is transferred to another tab. This helps in managing tab-specific\n * functionalities like maintaining session states, or performing tasks which\n * should only occur in one tab at a time.\n *\n * License: MIT\n * Author: Andrei (Ravy) Rovnyi\n */\nimport globalConfig from './config';\nimport type { TEvent } from \"./types\";\n\nexport class TabsWorker {\n\tprivate readonly tabId: string;\n\n\tconstructor() {\n\t\tthis.tabId = globalConfig.dict.tab_prefix + Date.now().toString();\n\t\tthis.init();\n\t}\n\n\t/**\n\t * Initializes event listeners for load, beforeunload, and storage events.\n\t */\n\tprivate init() {\n\t\tif (typeof window === 'undefined') return;\n\n\t\t// Callback for load event\n\t\tconst loadCb = () => {\n\t\t\tif (!localStorage.getItem(globalConfig.dict.primaryTabId)) {\n\t\t\t\tthis.setPrimaryTab(this.tabId);\n\t\t\t} else {\n\t\t\t\tthis.setSlaveTab(this.tabId);\n\t\t\t}\n\n\t\t\tthis.notifyTabStatus();\n\t\t};\n\n\t\t// Callback for beforeunload event\n\t\tconst beforeUnloadCb = () => {\n\t\t\tif (this.isPrimaryTab()) {\n\t\t\t\tthis.removeTabStatus(globalConfig.dict.primaryTabId);\n\t\t\t\tthis.transferPrimaryStatus();\n\t\t\t}\n\t\t\tthis.removeTabStatus(this.tabId);\n\t\t};\n\n\t\t// Callback for storage event\n\t\tconst storageCb = (event: StorageEvent) => {\n\t\t\tif (event.key === globalConfig.dict.primaryTabId) {\n\t\t\t\tthis.notifyTabStatus();\n\t\t\t}\n\t\t};\n\n\t\t// Adding event listeners\n\t\tif (document.readyState === \"complete\") {\n\t\t\tloadCb();\n\t\t} else {\n\t\t\twindow.addEventListener('load', loadCb);\n\t\t}\n\t\twindow.addEventListener('pagehide', beforeUnloadCb);\n\t\twindow.addEventListener('storage', storageCb);\n\t}\n\n\t/**\n\t * Sets a key-value pair in localStorage.\n\t * @param key - The key to set in localStorage.\n\t * @param value - The value to set in localStorage.\n\t */\n\tprivate set(key: string, value: string) {\n\t\tlocalStorage.setItem(key, value);\n\t}\n\n\t/**\n\t * Gets a value from localStorage by key.\n\t * @param key - The key to get from localStorage.\n\t * @returns The value associated with the key in localStorage.\n\t */\n\tprivate get(key: string): string | null {\n\t\treturn localStorage.getItem(key);\n\t}\n\n\t/**\n\t * Removes a key from localStorage.\n\t * @param key - The key to remove from localStorage.\n\t */\n\tprivate remove(key: string) {\n\t\tlocalStorage.removeItem(key);\n\t}\n\n\t/**\n\t * Sets the current tab as the primary tab.\n\t * @param id - The ID of the tab to set as primary.\n\t */\n\tprivate setPrimaryTab(id: string) {\n\t\tthis.set(globalConfig.dict.primaryTabId, id);\n\t\tthis.set(id, globalConfig.dict.primary);\n\t}\n\n\t/**\n\t * Sets the current tab as a slave tab.\n\t * @param id - The ID of the tab to set as slave.\n\t */\n\tprivate setSlaveTab(id: string) {\n\t\tthis.set(id, globalConfig.dict.slave);\n\t}\n\n\t/**\n\t * Transfers primary status to another tab if the current primary tab is closed.\n\t */\n\tprivate transferPrimaryStatus() {\n\t\tconst tabs = Object\n\t\t\t.keys(localStorage)\n\t\t\t.filter(key => key !== globalConfig.dict.primaryTabId && this.get(key) === globalConfig.dict.slave);\n\n\t\tif (tabs.length > 0) {\n\t\t\tthis.setPrimaryTab(tabs.at(0));\n\t\t} else {\n\t\t\tthis.remove(globalConfig.dict.primaryTabId);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the status of a tab from localStorage.\n\t * @param id - The ID of the tab to remove status for.\n\t */\n\tprivate removeTabStatus(id: string) {\n\t\tthis.remove(id);\n\t}\n\n\t/**\n\t * Notifies other tabs of the current tab's status (primary or slave).\n\t */\n\tprivate notifyTabStatus() {\n\t\tif (typeof window === 'undefined') return;\n\n\t\tconst event: TEvent = {\n\t\t\tdetail: {\n\t\t\t\ttabId: this.tabId,\n\t\t\t\tisPrimary: this.isPrimaryTab(),\n\t\t\t},\n\t\t};\n\n\t\twindow.dispatchEvent(new CustomEvent(globalConfig.dict.primaryStatusChanged, event))\n\t}\n\n\t/**\n\t * Checks if the current tab is the primary tab.\n\t * @returns True if the current tab is the primary tab, false otherwise.\n\t */\n\tpublic isPrimaryTab(): boolean {\n\t\treturn this.get(globalConfig.dict.primaryTabId) === this.tabId;\n\t}\n}\n","/**\n * @file TabsBroadcast.ts\n * @description A class for managing inter-tab communication via BroadcastChannel.\n *\n * This class implements a singleton pattern to ensure a single instance.\n * It allows for registering, emitting, and handling various types of events across different browser tabs.\n *\n * License: MIT\n * Author: Andrei (Ravy) Rovnyi\n */\nimport globalConfig from './config'\nimport { TabsWorker } from './tabsWorker'\nimport {ILayers, TDefaultConfig, TEvent, TLayer, TPayload} from './types';\n\n/**\n * TabsBroadcast class facilitates inter-tab communication using the BroadcastChannel API.\n * It ensures a single instance is used across the application and provides methods to register,\n * emit, and handle events.\n */\nexport class TabsBroadcast {\n    #channelName: string;\n    #listenOwnChannel: boolean;\n    #onBecomePrimaryCallback: (payload: any) => void;\n    #emitByPrimaryOnly: boolean;\n    #worker: TabsWorker;\n    #channel: null|BroadcastChannel;\n    #layers: ILayers\n    primary: boolean = false;\n\n    private static instance: null|TabsBroadcast;\n\n    constructor(config: null|TDefaultConfig = null) {\n        // Ensure singleton instance\n        if (TabsBroadcast.instance) return TabsBroadcast.instance;\n\n        this.setConfig(config)\n        this.#init();\n\n        TabsBroadcast.instance = this;\n    }\n\n    /**\n     * Initialize the BroadcastChannel and set up event listeners.\n     */\n    #init() {\n        if (!window) return\n\n        this.#worker = new TabsWorker();\n        this.#channel = new BroadcastChannel(this.#channelName);\n\n        this.#channel.onmessage = this.#onMessage.bind(this);\n        this.#channel.onmessageerror = this.#onError.bind(this);\n\n        this.primary = false;\n\n        this.#onBecomePrimary()\n    }\n\n    /**\n     * Set up the event listener for becoming the primary tab.\n     */\n    #onBecomePrimary() {\n        window.addEventListener(globalConfig.dict.primaryStatusChanged, (event: Event) => {\n            const _event = event as unknown as TEvent;\n\n            if (this.#worker.isPrimaryTab()) {\n                this.primary = true;\n                this.#onBecomePrimaryCallback(_event.detail);\n            } else {\n                this.primary = false;\n            }\n        }, { passive: true });\n    }\n\n    /**\n     * Checking for the existence of a layer. Creating a new layer if it does not exist\n     * @param {string} layer - the name of the layer you are looking for\n     * @private\n     */\n    #checkOrCreateLayer(layer: string = globalConfig.defaultConfig.layer) {\n        if (!this.#layers[layer]) {\n            this.#layers[layer] = {\n                name: layer,\n                listeners: []\n            }\n        }\n\n        return this.#layers[layer]\n    }\n\n    /**\n     * Processing incoming messages\n     * @param {MessageEvent<TPayload>} event - Incoming payload\n     * @private\n     */\n    #onMessage(event: MessageEvent<TPayload>) {\n        const { type, payload, layer } = event.data;\n\n        const _l = this.#checkOrCreateLayer(layer);\n\n        _l.listeners = _l.listeners.filter(item => {\n            if (item.type === type) {\n                item.callback({ type, payload, layer });\n\n                return !item.once;\n            }\n\n            return true;\n        });\n    };\n\n    /**\n     * Error handling in the broker's work\n     * @param {MessageEvent<any>} error - Error\n     * @private\n     */\n    #onError(error: MessageEvent) {\n        if (process.env.NODE_ENV === 'production') return;\n\n        console.error('Can\\'t parse message', error);\n    }\n\n    /**\n     * Register a callback to be executed whenever a message of the specified type is received.\n     * @param {string} type - The type of the message.\n     * @param {function} callback - The function to execute when a message of the specified type is received.\n     * @param {string} layer - The name of the layer to which the message is addressed.\n     */\n    on(type: string, callback: () => void, layer: string) {\n        this.#checkOrCreateLayer(layer)\n            .listeners\n            .push({ type, callback })\n    }\n\n    /**\n     * Register multiple callbacks to be executed whenever messages of specified types are received.\n     * @param {Array.<Array.<string, function, string>>} list - List of type-callback pairs.\n     */\n    onList(list: [string, () => void, string][]) {\n        if (!list.length) return;\n\n        list.forEach(([type, callback, layer]) => {\n            if (!type || !callback) return;\n\n            this.#checkOrCreateLayer(layer)\n                .listeners\n                .push({ type, callback })\n        });\n    }\n\n    /**\n     * Register a callback to be executed only once when a message of the specified type is received.\n     * @param {string} type - The type of the message.\n     * @param {function} callback - The function to execute when a message of the specified type is received.\n     * @param {string} layer - The name of the layer to which the message is addressed.\n     */\n    once(type: string, callback: () => void, layer: string) {\n        this.#checkOrCreateLayer(layer)\n            .listeners\n            .push({ type, callback, once: true })\n    }\n\n    /**\n     * Register multiple callbacks to be executed one-time when messages of specified types are received.\n     * @param {Array.<Array.<string, function>>} list - List of type-callback pairs.\n     */\n    onceList(list: [string, () => void, string][]) {\n        if (!list.length) return;\n\n        list.forEach(([type, callback, layer = globalConfig.defaultConfig.layer]) => {\n            if (!type || !callback) return;\n\n            this.#checkOrCreateLayer(layer)\n                .listeners\n                .push({ type, callback, once: true })\n        });\n    }\n\n    /**\n     * Unregister all callbacks of the specified type.\n     * @param {string} type - The type of the messages for which to unregister the callbacks.\n     * @param {string|null} [layer] - Specifying the layer to delete the message from.\n     */\n    off(type: string, layer: string|null = null) {\n        if (layer) {\n            this.#layers[layer].listeners.filter(item => item.type !== type);\n        } else {\n            for (const layerName in this.#layers) {\n                this.#layers[layerName].listeners.filter(item => item.type !== type);\n            }\n        }\n    }\n\n    /**\n     * Delete and unregister all callbacks of the specified layer.\n     * @param {string} layer - The name of the layer to be deleted.\n     */\n    deleteLayer(layer: string) {\n        const _l = this.#checkOrCreateLayer(layer);\n\n        _l.listeners = []\n        this.#layers[layer] = null\n        delete this.#layers[layer]\n    }\n\n    /**\n     * Emit a message to all listening tabs with the specified type, payload and layer.\n     * @param {string} type - The type of the message.\n     * @param {*} [payload=null] - The payload of the message.\n     * @param {string} [layer] - The name of the layer to which the message is addressed.\n     */\n    emit(type: string, payload: any = null, layer: string = globalConfig.defaultConfig.layer) {\n        if (this.#emitByPrimaryOnly && !this.#worker.isPrimaryTab()) return;\n\n        if (!this.#channel) return;\n\n        const message: TPayload = { type, payload, layer };\n        this.#channel.postMessage(message);\n\n        if (this.#listenOwnChannel) {\n            // @ts-ignore\n            this.#channel.onmessage({ data: message });\n        }\n    }\n\n    /**\n     * Check if the current tab is the primary tab.\n     * @returns {boolean} - True if the current tab is primary, false otherwise.\n     * @deprecated - Use `TabBroadcast.primary` for primary tab identify\n     */\n    isPrimary(): boolean {\n        return this.#worker.isPrimaryTab();\n    }\n\n    /**\n     * Set custom config properties\n     * @param {TDefaultConfig} config - Optional custom config\n     */\n    setConfig(config: null|TDefaultConfig) {\n        const _config = {\n            ...globalConfig.defaultConfig,\n            ...config\n        };\n\n        this.#channelName = _config.channelName;\n        this.#layers = {};\n        this.#listenOwnChannel = _config.listenOwnChannel;\n        this.#onBecomePrimaryCallback = _config.onBecomePrimary;\n        this.#emitByPrimaryOnly = _config.emitByPrimaryOnly;\n    }\n\n    /**\n     * Destroy the BroadcastChannel. Messages will no longer be received.\n     */\n    destroy() {\n        if (this.#channel) {\n            this.#channel.close();\n        }\n\n        TabsBroadcast.instance = null;\n        this.#channel = null;\n    }\n\n    /**\n     * Receive copy of events list\n     */\n    getEvents() {\n        const isOnlyDefaultLayer = Object.keys(this.#layers).length === 1 && this.#layers[globalConfig.defaultConfig.layer];\n\n        if (isOnlyDefaultLayer) {\n            return [ ...this.#layers[globalConfig.defaultConfig.layer].listeners ];\n        }\n\n        return Object.values(this.#layers).reduce((acc, layerData) => {\n            acc = [ ...acc, ...layerData.listeners ]\n            return acc\n        }, []);\n    }\n\n    /**\n     * Get a list of all available layers\n     */\n    getLayers() : string[] {\n        return Object.keys(this.#layers)\n    }\n}\n"],"names":["globalConfig","channelName","layer","listenOwnChannel","emitByPrimaryOnly","onBecomePrimary","tab_prefix","slave","primary","primaryTabId","primaryStatusChanged","TabsWorker","tabId","constructor","this","Date","now","toString","init","window","loadCb","localStorage","getItem","setSlaveTab","setPrimaryTab","notifyTabStatus","document","readyState","addEventListener","isPrimaryTab","removeTabStatus","transferPrimaryStatus","event","key","value","setItem","removeItem","id","set","tabs","Object","keys","filter","get","length","at","remove","detail","isPrimary","dispatchEvent","CustomEvent","_e","_t","_a","_r","_s","_i","_n","_r_instances","l_fn","o_fn","c_fn","h_fn","y_fn","TabsBroadcast","config","__privateAdd","onBecomePrimaryCallback","worker","channel","layers","instance","setConfig","type","callback","listeners","push","list","forEach","once","checkOrCreateLayer","item","layerName","payload","message","postMessage","onmessage","data","_config","destroy","close","values","reduce","acc","layerData","BroadcastChannel","bind","onmessageerror","_event","passive","name","onMessage","_l","onError","error","process","env","NODE_ENV","console","static"],"mappings":"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"}